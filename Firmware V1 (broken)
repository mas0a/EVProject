// ========================
// PIN DEFINITIONS
// ========================
const int ENA = 11;
const int IN1 = 10;
const int IN2 = 9;

const int ENC_A = 2;
const int ENC_B = 3;

// ========================
// WHEEL + ENCODER CONFIG
// ========================
const float WHEEL_DIAMETER_IN = 2.875;  // 2 7/8 inches

// MEASURED encoder spec
// 70 PPR measured on one channel
// Full quadrature = 70 * 4 = 280 CPR
const int MOTOR_TICKS_PER_REV = 280;

// Pulley ratio: motor 16T â†’ axle 20T
const float GEAR_RATIO = 16.0 / 20.0;

// Conversion factor
const float INCH_TO_M = 0.0254;
float wheelDiameterM;

// ========================
// DISTANCE + TIME
// ========================
const float TARGET_DISTANCE_M = 8.0;
const float SLOWDOWN_DISTANCE_M = 1.0;
const float TARGET_TIME_S = 15.0;
const unsigned long TARGET_TIME_MS = TARGET_TIME_S * 1000;

// ========================
// SPEED CONTROL
// ========================
const int MIN_START_PWM = 50;
const int MAX_CRUISE_PWM = 160;
const int INCH_PWM = 80;
const int INCH_DELAY_MS = 50;

// ========================
// SAFETY
// ========================
const unsigned long MAX_RUN_TIME_MS = 20000;

// ========================
// GLOBALS
// ========================
volatile long encoderCount = 0;
float metersPerTick;

// ========================
// ENCODER ISR (corrected)
// ========================
void encoderISR() {
  if (digitalRead(ENC_B) == HIGH) {
    encoderCount++;
  } else {
    encoderCount--;
  }
}

// ========================
// MOTOR CONTROL
// ========================
void motorForward(int pwm) {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  analogWrite(ENA, pwm);
}

void motorStop() {
  analogWrite(ENA, 0);
}

// ========================
// SETUP
// ========================
void setup() {
  pinMode(ENA, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);

  pinMode(ENC_A, INPUT_PULLUP);
  pinMode(ENC_B, INPUT_PULLUP);

  // Interrupt now uses single edge, stable counting
  attachInterrupt(digitalPinToInterrupt(ENC_A), encoderISR, RISING);

  wheelDiameterM = WHEEL_DIAMETER_IN * INCH_TO_M;

  metersPerTick =
    (3.14159 * wheelDiameterM) /
    (MOTOR_TICKS_PER_REV / GEAR_RATIO);

  Serial.begin(9600);
  Serial.println("RUN READY - STARTING IMMEDIATELY");
  Serial.print("Wheel diameter (m): ");
  Serial.println(wheelDiameterM, 6);
  Serial.print("Meters per tick: ");
  Serial.println(metersPerTick, 6);
  Serial.print("Target time (ms): ");
  Serial.println(TARGET_TIME_MS);
}

// ========================
// LOOP
// ========================
void loop() {
  encoderCount = 0;
  unsigned long startTime = millis();

  long targetTicks = TARGET_DISTANCE_M / metersPerTick;
  long slowTicks   = SLOWDOWN_DISTANCE_M / metersPerTick;

  Serial.print("Target distance (m): ");
  Serial.println(TARGET_DISTANCE_M, 3);
  Serial.print("Target ticks: ");
  Serial.println(targetTicks);

  int accelTimeMs = 1500;
  int steps = 30;
  int delayPerStep = accelTimeMs / steps;

  for (int i = 1; i <= steps; i++) {
    int pwm = map(i, 1, steps, MIN_START_PWM, MAX_CRUISE_PWM);
    motorForward(pwm);
    delay(delayPerStep);
  }

  bool inchingPhase = false;

  while (true) {
    long ticks = abs(encoderCount);
    float dist = ticks * metersPerTick;

    if (!inchingPhase && ticks >= (targetTicks - slowTicks)) {
      inchingPhase = true;
      motorStop();
      Serial.println("INCHING PHASE START");
    }

    if (inchingPhase) {
      long remainingTicks = targetTicks - ticks;
      if (remainingTicks <= 0) break;

      motorForward(INCH_PWM);
      delay(INCH_DELAY_MS);
      motorStop();
      delay(10);
    } else {
      motorForward(MAX_CRUISE_PWM);
    }

    unsigned long elapsed = millis() - startTime;
    unsigned long remainingTime =
      (TARGET_TIME_MS > elapsed) ? TARGET_TIME_MS - elapsed : 1;

    Serial.print("Ticks: "); Serial.print(ticks);
    Serial.print("  Dist: "); Serial.print(dist, 3);
    Serial.print("  PWM: "); Serial.print(inchingPhase ? INCH_PWM : MAX_CRUISE_PWM);
    Serial.print("  Time left (ms): "); Serial.println(remainingTime);

    if (millis() - startTime > MAX_RUN_TIME_MS) {
      Serial.println("TIMEOUT STOP");
      motorStop();
      break;
    }
  }

  Serial.println("TARGET REACHED - BRAKING");
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, HIGH);
  delay(50);
  motorStop();

  Serial.println("RUN COMPLETE");

  while (true) {}
}
