#include <Arduino.h>

// ========================
// EVENT CONFIGURATION
// ========================
// PATH TYPE: Set to true for arc path, false for straight path
bool useArcPath = false;

// STRAIGHT PATH SETTINGS
double targetDistance = 9.5;     // meters target dist.

// ARC PATH SETTINGS (only used if useArcPath = true)
double arcChordLength = 9.5;     // meters (straight-line distance to target)
double arcOffset = 1.0;          // meters (perpendicular distance from chord to arc midpoint)

// ========================
// MOTION PROFILE SETTINGS
// ========================
double accelDistance  = 1.00;    // meters to ramp up
double decelDistance  = 3.50;    // meters to ramp down

// HARD COAST COMPENSATION
const double coastSubtract = 0.27;

// PWM LIMITS
int maxPWM = 200;    // Cruise speed
int startPWM = 150;  // Initial acceleration PWM
int endPWM = 90;     // Final deceleration PWM

// ========================
// MOTOR DRIVER PINS
// ========================
#define ENA 11
#define IN1 9
#define IN2 10

// ========================
// ENCODER PINS
// ========================
#define ENCA 2
#define ENCB 3

// ========================
// PHYSICAL PARAMETERS
// ========================
double wheelDiameter = 6.0325;   // cm
double motorPPR = 70.0;
double gearRatio = 20.0 / 16.0;
double wheelbase = 60.96;        // cm (24 inches axle-to-axle)

// ========================
// STEERING CALIBRATION
// ========================
// Measured caliper settings for steering angles
// Format: {angle (degrees), caliper (mm)}
struct SteeringCalibration {
  double angle;      // degrees
  double caliper;    // mm (caliper reading)
} steeringTable[] = {
  {0.0,  0.0},       // Straight
  {2.0,  0.25},      // Small turn
  {5.0,  0.5},       // Medium turn
  {15.0, 5.24},      // Large turn
  {17.0, 10.4}       // Maximum turn (max caliper range)
};
const int numCalibrationPoints = 5;

// ========================
// CALCULATED ARC PARAMETERS
// ========================
double arcRadius = 0;            // meters (calculated)
double arcLength = 0;            // meters (calculated)
double steeringAngle = 0;        // degrees (calculated)
double caliperSetting = 0;       // mm (calculated from steering angle)
double initialOrientation = 0;   // degrees (calculated)

// ========================
// ENCODER VARIABLES
// ========================
volatile long encoderCount = 0;
long stopEncoderCount = 0;
long accelEndCount = 0;
long decelStartCount = 0;

// ========================
// TIMEOUT SETTINGS
// ========================
const unsigned long TIMEOUT_MS = 20000;  // 20 second timeout
unsigned long motionStartTime = 0;

// ========================
// MOTION PROFILE PHASES
// ========================
enum MotionPhase {
  ACCEL,
  CRUISE,
  DECEL,
  STOPPED
};

MotionPhase currentPhase = ACCEL;

// ========================
// STEERING ANGLE TO CALIPER CONVERSION
// ========================
double angleToCaliper(double angle) {
  // Linear interpolation between calibration points
  
  // Handle out of range (extrapolate or clamp)
  if (angle <= steeringTable[0].angle) {
    return steeringTable[0].caliper;
  }
  if (angle >= steeringTable[numCalibrationPoints - 1].angle) {
    return steeringTable[numCalibrationPoints - 1].caliper;
  }
  
  // Find bracketing points
  for (int i = 0; i < numCalibrationPoints - 1; i++) {
    if (angle >= steeringTable[i].angle && angle <= steeringTable[i + 1].angle) {
      // Linear interpolation
      double angle1 = steeringTable[i].angle;
      double angle2 = steeringTable[i + 1].angle;
      double caliper1 = steeringTable[i].caliper;
      double caliper2 = steeringTable[i + 1].caliper;
      
      double ratio = (angle - angle1) / (angle2 - angle1);
      return caliper1 + ratio * (caliper2 - caliper1);
    }
  }
  
  return 0;  // Fallback
}

// ========================
// ARC PATH CALCULATIONS
// ========================
void calculateArcParameters() {
  if (!useArcPath) {
    arcLength = targetDistance;
    arcRadius = 0;
    steeringAngle = 0;
    initialOrientation = 0;
    return;
  }
  
  // Given: chord length (C) and sagitta/offset (h)
  // Calculate: radius (R), arc length (L), steering angle, orientation
  
  double C = arcChordLength;  // Chord length
  double h = arcOffset;       // Sagitta (perpendicular offset)
  
  // Calculate radius using: R = (C² + 4h²) / (8h)
  arcRadius = (C * C + 4 * h * h) / (8 * h);
  
  // Calculate the central angle (theta) in radians
  // Using: sin(theta/2) = C / (2R)
  double halfTheta = asin(C / (2 * arcRadius));
  double theta = 2 * halfTheta;  // Central angle in radians
  
  // Calculate arc length: L = R * theta
  arcLength = arcRadius * theta;
  
  // Calculate steering angle for vehicle
  // Simple circular motion: tan(steering_angle) = wheelbase / turning_radius
  double wheelbaseMeters = wheelbase / 100.0;
  steeringAngle = atan(wheelbaseMeters / arcRadius) * (180.0 / PI);
  
  // Convert steering angle to caliper setting
  caliperSetting = angleToCaliper(steeringAngle);
  
  // Calculate initial orientation (angle at which to point the car)
  // This is half the central angle (tangent to the arc at start)
  initialOrientation = halfTheta * (180.0 / PI);
}

// ========================
// SETUP
// ========================
void setup() {
  Serial.begin(115200);
  
  pinMode(ENA, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(ENCA, INPUT_PULLUP);
  pinMode(ENCB, INPUT_PULLUP);
  
  attachInterrupt(digitalPinToInterrupt(ENCA), encoderISR, RISING);
  
  // -------- ARC PATH CALCULATIONS --------
  calculateArcParameters();
  
  // Use arc length as the actual travel distance
  double travelDistance = useArcPath ? arcLength : targetDistance;
  
  // Calculate commanded distance with coast compensation
  double commandedDistance = travelDistance - coastSubtract;
  if (commandedDistance < 0) commandedDistance = 0;
  
  // Calculate encoder count waypoints
  stopEncoderCount = distanceToCounts(commandedDistance);
  accelEndCount = distanceToCounts(accelDistance);
  decelStartCount = stopEncoderCount - distanceToCounts(decelDistance);
  
  // Validate profile
  if (accelEndCount >= decelStartCount) {
    Serial.println("WARNING: Accel+Decel distances exceed total distance!");
    Serial.println("Adjusting to triangular profile...");
    accelEndCount = stopEncoderCount / 2;
    decelStartCount = stopEncoderCount / 2;
  }
  
  // -------- PRINT CONFIGURATION --------
  Serial.println("=== TRAPEZOIDAL MOTION PROFILE CONTROLLER ===");
  Serial.println();
  
  if (useArcPath) {
    Serial.println("*** ARC PATH MODE ***");
    Serial.println("--- Arc Path Geometry ---");
    Serial.print("Chord length (straight-line distance): ");
    Serial.print(arcChordLength, 2);
    Serial.println(" m");
    Serial.print("Arc offset (sagitta): ");
    Serial.print(arcOffset, 2);
    Serial.println(" m");
    Serial.println();
    
    Serial.println("--- Calculated Arc Parameters ---");
    Serial.print("Arc radius: ");
    Serial.print(arcRadius, 3);
    Serial.println(" m");
    Serial.print("Arc length (actual travel): ");
    Serial.print(arcLength, 3);
    Serial.println(" m");
    Serial.print("Central angle: ");
    Serial.print((2 * asin(arcChordLength / (2 * arcRadius))) * (180.0 / PI), 2);
    Serial.println(" degrees");
    Serial.println();
    
    Serial.println("--- VEHICLE SETUP INSTRUCTIONS ---");
    Serial.println();
    Serial.println(">>> CALIPER SETTING <<<");
    Serial.print("Set caliper to: ");
    Serial.print(caliperSetting, 2);
    Serial.println(" mm");
    Serial.print("(This gives a steering angle of ");
    Serial.print(steeringAngle, 2);
    Serial.println(" degrees)");
    Serial.println();
    Serial.print("Turn radius: ");
    Serial.print(arcRadius, 2);
    Serial.println(" m");
    Serial.println();
    Serial.print("INITIAL ORIENTATION: Point car at ");
    Serial.print(initialOrientation, 2);
    Serial.println(" degrees");
    Serial.println("(Angle from straight line toward inside of curve)");
    Serial.println();
    Serial.println("   Visual guide:");
    Serial.println("   Start -----> [car at angle] ~~~arc~~~ Target");
    Serial.println("         \\              /");
    Serial.println("          \\   offset   /");
    Serial.println("           \\____h____/");
    Serial.println();
  } else {
    Serial.println("*** STRAIGHT PATH MODE ***");
    Serial.print("Target distance: ");
    Serial.print(targetDistance, 2);
    Serial.println(" m");
    Serial.println();
  }
  
  Serial.print("Commanded distance (m): ");
  Serial.println(commandedDistance, 3);
  Serial.println();
  
  Serial.println("--- Motion Profile Waypoints ---");
  Serial.print("Accel end: ");
  Serial.print(countsToDistance(accelEndCount), 2);
  Serial.print(" m (count: ");
  Serial.print(accelEndCount);
  Serial.println(")");
  
  Serial.print("Cruise: ");
  Serial.print(countsToDistance(accelEndCount), 2);
  Serial.print(" -> ");
  Serial.print(countsToDistance(decelStartCount), 2);
  Serial.println(" m");
  
  Serial.print("Decel start: ");
  Serial.print(countsToDistance(decelStartCount), 2);
  Serial.print(" m (count: ");
  Serial.print(decelStartCount);
  Serial.println(")");
  
  Serial.print("Stop: ");
  Serial.print(countsToDistance(stopEncoderCount), 2);
  Serial.print(" m (count: ");
  Serial.print(stopEncoderCount);
  Serial.println(")");
  Serial.println();
  
  Serial.print("PWM Range: ");
  Serial.print(startPWM);
  Serial.print(" -> ");
  Serial.print(maxPWM);
  Serial.print(" -> ");
  Serial.print(endPWM);
  Serial.println();
  Serial.println();
  Serial.println("Starting in 3 seconds...");
  Serial.println();
  
  delay(3000);
  encoderCount = 0;
  motionStartTime = millis();
}

// ========================
// MAIN LOOP
// ========================
void loop() {
  static unsigned long lastPrint = 0;
  int pwmOutput;
  
  // -------- TRAPEZOIDAL PROFILE CONTROL --------
  if (encoderCount < accelEndCount) {
    // ACCELERATION PHASE
    currentPhase = ACCEL;
    double progress = (double)encoderCount / (double)accelEndCount;
    progress = constrain(progress, 0.0, 1.0);
    pwmOutput = startPWM + progress * (maxPWM - startPWM);
    
  } else if (encoderCount < decelStartCount) {
    // CRUISE PHASE
    currentPhase = CRUISE;
    pwmOutput = maxPWM;
    
  } else if (encoderCount < stopEncoderCount) {
    // DECELERATION PHASE
    currentPhase = DECEL;
    double remaining = stopEncoderCount - encoderCount;
    double decelCounts = stopEncoderCount - decelStartCount;
    double ratio = remaining / decelCounts;
    ratio = constrain(ratio, 0.0, 1.0);
    pwmOutput = endPWM + ratio * (maxPWM - endPWM);
    
  } else {
    // STOPPED
    currentPhase = STOPPED;
    pwmOutput = 0;
  }
  
  // Apply motor command
  if (currentPhase != STOPPED) {
    motorForward(pwmOutput);
  } else {
    motorStop();
  }
  
  // -------- SERIAL OUTPUT --------
  if (millis() - lastPrint >= 200) {
    lastPrint = millis();
    
    Serial.print("Phase: ");
    switch(currentPhase) {
      case ACCEL:   Serial.print("ACCEL  "); break;
      case CRUISE:  Serial.print("CRUISE "); break;
      case DECEL:   Serial.print("DECEL  "); break;
      case STOPPED: Serial.print("STOPPED"); break;
    }
    Serial.print(" | ENC: ");
    Serial.print(encoderCount);
    Serial.print(" | PWM: ");
    Serial.print(pwmOutput);
    Serial.print(" | Dist: ");
    Serial.print(countsToDistance(encoderCount), 3);
    Serial.print("m | Time: ");
    Serial.print((millis() - motionStartTime) / 1000.0, 1);
    Serial.println("s");
  }
  
  // -------- TIMEOUT CHECK --------
  if (millis() - motionStartTime >= TIMEOUT_MS) {
    motorStop();
    Serial.println();
    Serial.println("=== TIMEOUT! ===");
    Serial.print("Motion exceeded ");
    Serial.print(TIMEOUT_MS / 1000);
    Serial.println(" seconds");
    Serial.print("Distance traveled: ");
    Serial.print(countsToDistance(encoderCount), 4);
    Serial.println(" m");
    
    while (true) {
      delay(100);
    }
  }
  
  // -------- STOP CONDITION --------
  if (currentPhase == STOPPED) {
    double finalTime = (millis() - motionStartTime) / 1000.0;
    double finalDistance = countsToDistance(encoderCount);
    
    Serial.println();
    Serial.println("=== MOTION COMPLETE ===");
    Serial.print("Final distance: ");
    Serial.print(finalDistance, 4);
    Serial.println(" m");
    
    if (useArcPath) {
      Serial.print("Target arc length: ");
      Serial.print(arcLength, 4);
      Serial.println(" m");
      Serial.print("Error: ");
      Serial.print((finalDistance - arcLength) * 100, 2);
      Serial.println(" cm");
    } else {
      Serial.print("Target distance: ");
      Serial.print(targetDistance, 4);
      Serial.println(" m");
      Serial.print("Error: ");
      Serial.print((finalDistance - targetDistance) * 100, 2);
      Serial.println(" cm");
    }
    
    Serial.print("Time: ");
    Serial.print(finalTime, 2);
    Serial.println(" s");
    
    while (true) {
      delay(100);
    }
  }
}

// ========================
// MOTOR CONTROL
// ========================
void motorForward(int pwm) {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  analogWrite(ENA, pwm);
}

void motorStop() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  analogWrite(ENA, 0);
}

// ========================
// ENCODER ISR
// ========================
void encoderISR() {
  if (digitalRead(ENCB) == LOW) encoderCount++;
  else encoderCount--;
}

// ========================
// DISTANCE CALCULATIONS
// ========================
long distanceToCounts(double meters) {
  double cm = meters * 100.0;
  double wheelCirc = PI * wheelDiameter;
  double wheelRevs = cm / wheelCirc;
  double effectivePPR = motorPPR * gearRatio;
  return (long)(wheelRevs * effectivePPR);
}

double countsToDistance(long counts) {
  double wheelCirc = PI * wheelDiameter;
  double effectivePPR = motorPPR * gearRatio;
  double wheelRevs = (double)counts / effectivePPR;
  return (wheelRevs * wheelCirc) / 100.0;
}
