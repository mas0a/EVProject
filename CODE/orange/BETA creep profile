#include <Arduino.h>

// ========================
// EVENT CONFIGURATION (Set per competition)
// ========================
double targetDistance = 9.5;   // meters (7-10m in 0.25m intervals)
double targetTime = 15.0;      // seconds (10-20s in 0.5s intervals)

// ========================
// FIXED PROFILE STRUCTURE
// ========================
double accelDistance  = 1.00;   // meters to ramp up
double decelDistance  = 3.50;   // meters to ramp down
double creepDistance  = 1.00;   // meters for final creep phase
int creepPWM = 100;             // PWM for creep phase

// BASE PWM SETTINGS (will be auto-adjusted for time)
int basePWM = 200;              // Baseline cruise speed
int startPWM = 150;             // Initial acceleration PWM
int endPWM = 90;                // End of deceleration PWM

// VELOCITY CALIBRATION (measure your actual speed!)
double baseVelocity = 0.62;     // m/s at basePWM (200) - CALIBRATE THIS!
double creepVelocity = 0.15;    // m/s at creepPWM (100) - CALIBRATE THIS!

// COAST COMPENSATION
const double coastSubtract = 0.27;

// ========================
// CALCULATED VALUES (Auto-computed)
// ========================
int adjustedMaxPWM = basePWM;   // Will be calculated in setup()

// ========================
// MOTOR DRIVER PINS
// ========================
#define ENA 11
#define IN1 9
#define IN2 10

// ========================
// ENCODER PINS
// ========================
#define ENCA 2
#define ENCB 3

// ========================
// PHYSICAL PARAMETERS
// ========================
double wheelDiameter = 6.0325;   // cm
double motorPPR = 70.0;
double gearRatio = 20.0 / 16.0;

// ========================
// ENCODER VARIABLES
// ========================
volatile long encoderCount = 0;
long stopEncoderCount = 0;
long accelEndCount = 0;
long decelStartCount = 0;
long creepStartCount = 0;

// ========================
// TIMEOUT SETTINGS
// ========================
const unsigned long TIMEOUT_MS = 25000;  // 25 second timeout
unsigned long motionStartTime = 0;

// ========================
// MOTION PROFILE PHASES
// ========================
enum MotionPhase {
  ACCEL,
  CRUISE,
  DECEL,
  CREEP,
  STOPPED
};

MotionPhase currentPhase = ACCEL;

// ========================
// SETUP
// ========================
void setup() {
  Serial.begin(115200);
  
  pinMode(ENA, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(ENCA, INPUT_PULLUP);
  pinMode(ENCB, INPUT_PULLUP);
  
  attachInterrupt(digitalPinToInterrupt(ENCA), encoderISR, RISING);
  
  // -------- TIME-BASED PWM CALCULATION --------
  Serial.println("=== ADAPTIVE TRAPEZOIDAL MOTION PROFILE ===");
  Serial.println();
  Serial.println("--- Event Configuration ---");
  Serial.print("Target Distance: ");
  Serial.print(targetDistance, 2);
  Serial.println(" m");
  Serial.print("Target Time: ");
  Serial.print(targetTime, 1);
  Serial.println(" s");
  Serial.println();
  
  // Calculate fast profile distance (excluding creep)
  double fastDistance = targetDistance - creepDistance - coastSubtract;
  double cruiseDistance = fastDistance - accelDistance - decelDistance;
  
  // Estimate time needed with base PWM settings
  // Time = accel_time + cruise_time + decel_time + creep_time
  double accelTime = (accelDistance / baseVelocity) * 2.0;  // Average velocity during accel
  double cruiseTime = cruiseDistance / baseVelocity;
  double decelTime = (decelDistance / baseVelocity) * 2.0;  // Average velocity during decel
  double creepTime = creepDistance / creepVelocity;
  double estimatedTime = accelTime + cruiseTime + decelTime + creepTime;
  
  // Calculate time scaling factor
  double timeScale = estimatedTime / targetTime;
  adjustedMaxPWM = constrain((int)(basePWM * timeScale), 100, 255);
  
  Serial.println("--- Time Calibration ---");
  Serial.print("Estimated time at base PWM (");
  Serial.print(basePWM);
  Serial.print("): ");
  Serial.print(estimatedTime, 2);
  Serial.println(" s");
  Serial.print("Time scale factor: ");
  Serial.println(timeScale, 3);
  Serial.print("Adjusted max PWM: ");
  Serial.print(adjustedMaxPWM);
  Serial.print(" (was ");
  Serial.print(basePWM);
  Serial.println(")");
  Serial.println();
  
  // Calculate commanded distance with coast compensation
  double commandedDistance = targetDistance - coastSubtract;
  if (commandedDistance < 0) commandedDistance = 0;
  
  // Calculate encoder count waypoints
  stopEncoderCount = distanceToCounts(commandedDistance);
  accelEndCount = distanceToCounts(accelDistance);
  creepStartCount = stopEncoderCount - distanceToCounts(creepDistance);
  decelStartCount = creepStartCount - distanceToCounts(decelDistance);
  
  // Validate profile
  if (accelEndCount >= decelStartCount) {
    Serial.println("WARNING: Accel+Decel distances exceed available distance!");
    Serial.println("Adjusting to triangular profile...");
    long availableCounts = creepStartCount;
    accelEndCount = availableCounts / 2;
    decelStartCount = availableCounts / 2;
  }
  
  // Print configuration
  Serial.println("--- Motion Profile Waypoints ---");
  Serial.print("Phase 1 - ACCEL (0 -> ");
  Serial.print(countsToDistance(accelEndCount), 2);
  Serial.print(" m) | Count: ");
  Serial.println(accelEndCount);
  
  Serial.print("Phase 2 - CRUISE (");
  Serial.print(countsToDistance(accelEndCount), 2);
  Serial.print(" -> ");
  Serial.print(countsToDistance(decelStartCount), 2);
  Serial.print(" m) | Count: ");
  Serial.print(accelEndCount);
  Serial.print(" -> ");
  Serial.println(decelStartCount);
  
  Serial.print("Phase 3 - DECEL (");
  Serial.print(countsToDistance(decelStartCount), 2);
  Serial.print(" -> ");
  Serial.print(countsToDistance(creepStartCount), 2);
  Serial.print(" m) | Count: ");
  Serial.print(decelStartCount);
  Serial.print(" -> ");
  Serial.println(creepStartCount);
  
  Serial.print("Phase 4 - CREEP (");
  Serial.print(countsToDistance(creepStartCount), 2);
  Serial.print(" -> ");
  Serial.print(countsToDistance(stopEncoderCount), 2);
  Serial.print(" m) | Count: ");
  Serial.print(creepStartCount);
  Serial.print(" -> ");
  Serial.println(stopEncoderCount);
  
  Serial.println();
  Serial.print("PWM Profile: ");
  Serial.print(startPWM);
  Serial.print(" (start) -> ");
  Serial.print(adjustedMaxPWM);
  Serial.print(" (cruise) -> ");
  Serial.print(endPWM);
  Serial.print(" (decel end) -> ");
  Serial.print(creepPWM);
  Serial.println(" (creep)");
  Serial.println();
  Serial.println("Starting in 1 second...");
  Serial.println();
  
  delay(1000);
  encoderCount = 0;
  motionStartTime = millis();
}

// ========================
// MAIN LOOP
// ========================
void loop() {
  static unsigned long lastPrint = 0;
  int pwmOutput;
  
  // -------- FOUR-PHASE PROFILE CONTROL --------
  if (encoderCount < accelEndCount) {
    // PHASE 1: ACCELERATION
    currentPhase = ACCEL;
    double progress = (double)encoderCount / (double)accelEndCount;
    progress = constrain(progress, 0.0, 1.0);
    pwmOutput = startPWM + progress * (adjustedMaxPWM - startPWM);
    
  } else if (encoderCount < decelStartCount) {
    // PHASE 2: CRUISE
    currentPhase = CRUISE;
    pwmOutput = adjustedMaxPWM;
    
  } else if (encoderCount < creepStartCount) {
    // PHASE 3: DECELERATION
    currentPhase = DECEL;
    double remaining = creepStartCount - encoderCount;
    double decelCounts = creepStartCount - decelStartCount;
    double ratio = remaining / decelCounts;
    ratio = constrain(ratio, 0.0, 1.0);
    pwmOutput = endPWM + ratio * (adjustedMaxPWM - endPWM);
    
  } else if (encoderCount < stopEncoderCount) {
    // PHASE 4: CREEP (Final precision phase)
    currentPhase = CREEP;
    pwmOutput = creepPWM;
    
  } else {
    // STOPPED
    currentPhase = STOPPED;
    pwmOutput = 0;
  }
  
  // Apply motor command
  if (currentPhase != STOPPED) {
    motorForward(pwmOutput);
  } else {
    motorStop();
  }
  
  // -------- SERIAL OUTPUT --------
  if (millis() - lastPrint >= 200) {
    lastPrint = millis();
    
    Serial.print("Phase: ");
    switch(currentPhase) {
      case ACCEL:   Serial.print("ACCEL "); break;
      case CRUISE:  Serial.print("CRUISE"); break;
      case DECEL:   Serial.print("DECEL "); break;
      case CREEP:   Serial.print("CREEP "); break;
      case STOPPED: Serial.print("STOP  "); break;
    }
    Serial.print(" | ENC: ");
    Serial.print(encoderCount);
    Serial.print(" | PWM: ");
    Serial.print(pwmOutput);
    Serial.print(" | Dist: ");
    Serial.print(countsToDistance(encoderCount), 3);
    Serial.print("m | Time: ");
    Serial.print((millis() - motionStartTime) / 1000.0, 1);
    Serial.println("s");
  }
  
  // -------- TIMEOUT CHECK --------
  if (millis() - motionStartTime >= TIMEOUT_MS) {
    motorStop();
    Serial.println();
    Serial.println("=== TIMEOUT! ===");
    Serial.print("Motion exceeded ");
    Serial.print(TIMEOUT_MS / 1000);
    Serial.println(" second timeout");
    Serial.print("Distance traveled: ");
    Serial.print(countsToDistance(encoderCount), 4);
    Serial.println(" m");
    Serial.print("Target distance: ");
    Serial.print(targetDistance, 4);
    Serial.println(" m");
    
    while (true) {
      delay(100);
    }
  }
  
  // -------- STOP CONDITION --------
  if (currentPhase == STOPPED) {
    double finalTime = (millis() - motionStartTime) / 1000.0;
    double finalDistance = countsToDistance(encoderCount);
    
    Serial.println();
    Serial.println("=== MOTION COMPLETE ===");
    Serial.print("Final distance: ");
    Serial.print(finalDistance, 4);
    Serial.print(" m (target: ");
    Serial.print(targetDistance, 2);
    Serial.println(" m)");
    Serial.print("Distance error: ");
    Serial.print((finalDistance - targetDistance) * 100, 2);
    Serial.println(" cm");
    Serial.println();
    Serial.print("Final time: ");
    Serial.print(finalTime, 2);
    Serial.print(" s (target: ");
    Serial.print(targetTime, 1);
    Serial.println(" s)");
    Serial.print("Time error: ");
    Serial.print(finalTime - targetTime, 2);
    Serial.println(" s");
    
    while (true) {
      delay(100);
    }
  }
}

// ========================
// MOTOR CONTROL
// ========================
void motorForward(int pwm) {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  analogWrite(ENA, pwm);
}

void motorStop() {
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  analogWrite(ENA, 0);
}

// ========================
// ENCODER ISR
// ========================
void encoderISR() {
  if (digitalRead(ENCB) == LOW) encoderCount++;
  else encoderCount--;
}

// ========================
// DISTANCE CALCULATIONS
// ========================
long distanceToCounts(double meters) {
  double cm = meters * 100.0;
  double wheelCirc = PI * wheelDiameter;
  double wheelRevs = cm / wheelCirc;
  double effectivePPR = motorPPR * gearRatio;
  return (long)(wheelRevs * effectivePPR);
}

double countsToDistance(long counts) {
  double wheelCirc = PI * wheelDiameter;
  double effectivePPR = motorPPR * gearRatio;
  double wheelRevs = (double)counts / effectivePPR;
  return (wheelRevs * wheelCirc) / 100.0;
}
