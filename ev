
        #include <Arduino.h>
        #include <PID_v1.h>

        // ========================
        // CONFIGURATION
        // ========================
        const float TARGET_DISTANCE_M = 3.0;  // <-- Set your distance here (meters)
        const float TARGET_TIME_S = 5.0;      // <-- Set your target time here (seconds)

        // ========================
        // PIN DEFINITIONS
        // ========================
        const int ENA   = 11;
        const int IN1   = 10;
        const int IN2   = 9;


        const int ENC_A = 2;
        const int ENC_B = 3;

      // ========================
      // PHYSICAL PARAMETERS
      // ========================
      const float WHEEL_DIAMETER_M    = 0.073025;   // 2 7/8 inches
      const int   ENCODER_CPR         = 30;        // JGB37-520 PPR (on motor shaft)
      const float GEAR_RATIO          = 16.0 / 20.0;  // motor 16t / wheel 20t (wheel moves slower)
      const int   QUADRATURE_MULT     = 1;          // 1x decoding (single A channel only)        // ========================
        // PID TUNING
        // ========================
        //tweak porportional, then derivitave, then integral (you probably wont need to tweak integral)
        const double Kp = 0.5;
        const double Ki = 0.01;
        const double Kd = 0.05;

        // ========================
        // MOTOR LIMITS
        // ========================
        const int PWM_MAX    = 255;
        const int PWM_MIN    = 200;  // Increased from 150 to overcome stall
        const unsigned long TIMEOUT_MS = 20000;

        // ========================
        // ENCODER (thread-safe)
        // ========================
        volatile long encoderCount = 0;
        volatile unsigned long lastISRTime = 0;
        const unsigned long ISR_DEBOUNCE_US = 2000;  // 2ms debounce

      // Count only on A-channel rising edges (simplest, most reliable)
      void encoderISR_A() {
          unsigned long now = micros();
          if (now - lastISRTime < ISR_DEBOUNCE_US) return;  // Debounce
          lastISRTime = now;
          encoderCount++;
      }

      // Keep ISR_B empty but still attached (for compatibility)
      void encoderISR_B() {
          // Do nothing - we only count A channel rising edges
      }        long readEncoder() {
            noInterrupts();
            long val = encoderCount;
            interrupts();
            return val;
        }

        void resetEncoder() {
            noInterrupts();
            encoderCount = 0;
            interrupts();
        }

        // ========================
        // MOTOR CONTROL
        // ========================
      void motorForward(int pwm) {
          digitalWrite(IN1, HIGH);
          digitalWrite(IN2, LOW);
          analogWrite(ENA, pwm);
      }        void motorStop() {
            digitalWrite(IN1, LOW);
            digitalWrite(IN2, LOW);
            analogWrite(ENA, 0);
        }

        void motorBrake() {
            digitalWrite(IN1, HIGH);
            digitalWrite(IN2, HIGH);
            analogWrite(ENA, 255);
        }

        // ========================
        // GLOBALS
        // ========================
        float metersPerTick;
        long targetTicks;

        double pidInput    = 0;
        double pidOutput   = 0;
        double pidSetpoint = 0;

        PID myPID(&pidInput, &pidOutput, &pidSetpoint, Kp, Ki, Kd, DIRECT);

        // ========================
        // SETUP
        // ========================
        void setup() {
            // Motor pins
            pinMode(ENA, OUTPUT);
            pinMode(IN1, OUTPUT);
            pinMode(IN2, OUTPUT);
            
            // Encoder pins
            pinMode(ENC_A, INPUT_PULLUP);
            pinMode(ENC_B, INPUT_PULLUP);
            
            // Attach both interrupts for 4x resolution
            attachInterrupt(digitalPinToInterrupt(ENC_A), encoderISR_A, RISING);
            attachInterrupt(digitalPinToInterrupt(ENC_B), encoderISR_B, CHANGE);
            
            // Calculate meters per tick
            float wheelCircumference = PI * WHEEL_DIAMETER_M;
            float ticksPerWheelRev = ENCODER_CPR * GEAR_RATIO * QUADRATURE_MULT;
            metersPerTick = wheelCircumference / ticksPerWheelRev;
            
            // Calculate target
            targetTicks = (long)(TARGET_DISTANCE_M / metersPerTick);
            pidSetpoint = targetTicks;
            
            // Configure PID
            myPID.SetMode(AUTOMATIC);
            myPID.SetOutputLimits(0, PWM_MAX);
            myPID.SetSampleTime(10);  // 100 Hz
            
            // Serial
            Serial.begin(115200);
            Serial.println(F("\n=== DISTANCE ROBOT ==="));
            Serial.print(F("Target: "));
            Serial.print(TARGET_DISTANCE_M, 2);
            Serial.print(F(" m ("));
            Serial.print(targetTicks);
            Serial.println(F(" ticks)"));
            Serial.print(F("Resolution: "));
            Serial.print(metersPerTick * 1000, 4);
            Serial.println(F(" mm/tick"));
            Serial.println();
            
            delay(1000);  // Brief pause before starting
        }

        // ========================
        // MAIN LOOP
        // ========================
        // ========================
        // CONTROL CONSTANTS
        // ========================
        const long  STOP_TOLERANCE_TICKS = 5;   // how close is "close enough"
        const int   SOFT_MIN_PWM         = 200; // Increased friction compensation
        const int   BRAKE_TIME_MS        = 40;
        const float PULSE_ZONE_M         = 1.0; // Enter pulsing mode when 1m is LEFT (at 2m traveled)
        const int   PULSE_DURATION_MS    = 200; // How long to drive (ms)
        const int   PULSE_WAIT_MS        = 300; // How long to wait between pulses (ms)
        const int   PULSE_HOLD_PWM       = 150; // Hold brake during wait to prevent backslip

        void loop() {
            static unsigned long startTime = millis();
            static unsigned long lastPrint = 0;
            static bool running = true;
            static bool inPulseMode = false;
            static unsigned long pulseStartTime = 0;
            static bool pulseDriving = false;

            if (!running) {
                delay(100);
                return;
            }

            unsigned long now = millis();

            // Timeout safety
            if (now - startTime > TIMEOUT_MS) {
                motorStop();
                myPID.SetMode(MANUAL);
                Serial.println(F("ERROR: Timeout"));
                running = false;
                return;
            }

            // Read encoder with sanity check (cap at 2x target to catch noise)
            long ticks = readEncoder();  // Remove negation - encoder counts correctly
            long maxTicks = (long)(TARGET_DISTANCE_M * 2.0 / metersPerTick);
            if (ticks > maxTicks) {
                ticks = maxTicks;  // Cap but don't reset
            }
            long error = targetTicks - ticks;
            float currentDistance = ticks * metersPerTick;
            float distanceToTarget = TARGET_DISTANCE_M - currentDistance;
            float elapsedTime = (now - startTime) / 1000.0;  // Convert to seconds
            
            // Debug: print raw encoder count every 1 second
            static unsigned long lastEncoderDebug = 0;
            if (now - lastEncoderDebug >= 1000) {
                Serial.print(F("DEBUG: Raw encoder count = "));
                Serial.println(readEncoder());
                lastEncoderDebug = now;
            }

            // PULSE MODE: Enter when 1m is LEFT to target (vehicle traveled 2m)
            // COMMENTED OUT - running pure PID for full distance
            /*
            if (!inPulseMode && distanceToTarget <= PULSE_ZONE_M && currentDistance >= (TARGET_DISTANCE_M - PULSE_ZONE_M)) {
                inPulseMode = true;
                pulseStartTime = now;
                pulseDriving = true;
                Serial.println(F("\n>>> ENTERING PULSE MODE <<<"));
            }
            */

            // Handle pulse mode
            if (inPulseMode) {
                unsigned long pulseElapsed = now - pulseStartTime;
                
                if (pulseDriving) {
                    // Drive for PULSE_DURATION_MS
                    if (pulseElapsed < PULSE_DURATION_MS) {
                        motorForward(PWM_MIN + 20);
                    } else {
                        motorStop();
                        pulseDriving = false;
                        pulseStartTime = now;
                    }
                } else {
                    // Wait between pulses - use holding brake to prevent backslip
                    motorBrake();  // Hold position during wait
                    
                    if (pulseElapsed >= PULSE_WAIT_MS) {
                        if (abs(error) <= STOP_TOLERANCE_TICKS) {
                            // Reached target
                            motorStop();
                            myPID.SetMode(MANUAL);
                            pidOutput = 0;
                            inPulseMode = false;

                            Serial.println();
                            Serial.println(F("=== TARGET REACHED (PULSE MODE) ==="));
                            Serial.print(F("Target Dist: "));
                            Serial.print(TARGET_DISTANCE_M, 3);
                            Serial.println(F(" m"));
                            Serial.print(F("Actual Dist: "));
                            Serial.print(currentDistance, 3);
                            Serial.println(F(" m"));
                            Serial.print(F("Distance Error:  "));
                            Serial.print((currentDistance - TARGET_DISTANCE_M) * 100, 1);
                            Serial.println(F(" cm"));
                            Serial.print(F("Actual Time:   "));
                            Serial.print(elapsedTime, 4);
                            Serial.println(F(" s"));
                            Serial.print(F("Target Time: "));
                            Serial.print(TARGET_TIME_S, 4);
                            Serial.println(F(" s"));
                            Serial.print(F("Time Error: "));
                            Serial.print(elapsedTime - TARGET_TIME_S, 4);
                            Serial.println(F(" s"));

                            running = false;
                            return;
                        } else {
                            pulseDriving = true;
                            pulseStartTime = now;
                        }
                    }
                }

                // Debug output in pulse mode
                if (now - lastPrint >= 100) {
                    Serial.print(F("T: "));
                    Serial.print(elapsedTime, 4);
                    Serial.print(F("s | Dist: "));
                    Serial.print(currentDistance, 4);
                    Serial.print(F("m | PWM: "));
                    Serial.print(PWM_MIN + 20);
                    Serial.print(F(" | State: "));
                    Serial.println(pulseDriving ? F("DRIVE") : F("WAIT"));
                    lastPrint = now;
                }
            } else {
                // NORMAL PID MODE
                pidInput = ticks;
                myPID.Compute();

                int pwm = (int)pidOutput;
                
                // Force minimum power to overcome friction
                if (abs(error) > STOP_TOLERANCE_TICKS) {
                    pwm = max(pwm, SOFT_MIN_PWM);
                }

                // Drive logic
                if (abs(error) > STOP_TOLERANCE_TICKS) {
                    motorForward(pwm);
                } else {
                    // Target reached cleanly
                    motorBrake();
                    delay(BRAKE_TIME_MS);
                    motorStop();

                    myPID.SetMode(MANUAL);
                    pidOutput = 0;

                    Serial.println();
                    Serial.println(F("=== TARGET REACHED ==="));
                    Serial.print(F("Target Dist: "));
                    Serial.print(TARGET_DISTANCE_M, 3);
                    Serial.println(F(" m"));
                    Serial.print(F("Actual Dist: "));
                    Serial.print(currentDistance, 3);
                    Serial.println(F(" m"));
                    Serial.print(F("Distance Error:  "));
                    Serial.print((currentDistance - TARGET_DISTANCE_M) * 100, 1);
                    Serial.println(F(" cm"));
                    Serial.print(F("Actual Time:   "));
                    Serial.print(elapsedTime, 4);
                    Serial.println(F(" s"));
                    Serial.print(F("Target Time: "));
                    Serial.print(TARGET_TIME_S, 4);
                    Serial.println(F(" s"));
                    Serial.print(F("Time Error: "));
                    Serial.print(elapsedTime - TARGET_TIME_S, 4);
                    Serial.println(F(" s"));

                    running = false;
                    return;
                }

                // Debug output (100 ms)
                if (now - lastPrint >= 100) {
                    Serial.print(F("T: "));
                    Serial.print(elapsedTime, 4);
                    Serial.print(F("s | Dist: "));
                    Serial.print(currentDistance, 4);
                    Serial.print(F("m | PWM: "));
                    Serial.println(pwm);
                    lastPrint = now;
                }
            }

            delay(10);
        }
